<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<link rel="stylesheet" href="css/metro-bootstrap.css">
		<link rel="stylesheet" href="css/metro-bootstrap-responsive.css">
		<link rel="stylesheet" href="css/iconFont.css">
		<link rel="stylesheet" href="js/prettify/prettify.css">

        <script src="js/jquery/jquery.min.js"></script>
        <script src="js/jquery/jquery.widget.min.js"></script>
        <script src="js/jquery/jquery.mousewheel.js"></script>
		<script src="js/prettify/prettify.js"></script>
        <script src="js/metro/metro.min.js"></script>
		
		<script src="js/docs.js"></script>
		<script src="js/github.info.js"></script>
	
		<title>Координатные оси</title>
	</head>
	<body class="metro">
		<div class="container">
			<div align="center">
		<h1>Координатные оси</h1>
	</div>
	<br/>
	<p>Освоив масштабирование с использованием D3, мы построили такую точечную диаграмму:</p>
	<img src="images/axes_1.png" alt="Результат работы кода">
	<p>Давайте добавим горизонтальную и вертикальную оси, чтобы мы могли избавиться от ужасных красных цифр, захламляющих нашу диаграмму.</p>
	<br/>
	<h3>Знакомство с осями</h3>
	<p>Подобно масштабирующей функции, оси в D3 также являются функциями, параметры которых вам необходимо определить. В отличии от масштабирующей функции, когда вызывается функция построения оси, она не возвращает значение, она генерирует визуальные элементы оси, а именно линии, метки и отметки.</p>
	<p>Заметьте, что функции построения осей имеют свою специфику, так как они генерируют SVG-элементы. Также оси предназначены для использования с количественной шкалой(вместо порядковой).</p>
	<br/>
	<h3>Настройка осей</h3>
	<p>Используйте d3.svg.axis() для создания общего вида функцию оси:</p>
	<pre class="prettyprint linenums">var xAxis = d3.svg.axis();</pre>
	<p>Как минимум, каждой оси необходимо знать, с каким масштабированием ей работать. Для этого хорошо подойдет наша масштабирующая функция по х из предыдущей главы:</p>
	<pre class="prettyprint linenums">xAxis.scale(xScale);</pre>
	<p>Также мы можем указать, где должны отображаться метки на оси относительно самой себя. По умолчанию они будут отображаться снизу(хотя это значение по умолчанию, не повредит указать  местоположение явно).</p>
	<pre class="prettyprint linenums">xAxis.orient("bottom");</pre>
	<p>Конечно, мы можем быть более краткими, и разместить код в одну строчку:</p>
	<pre class="prettyprint linenums">
var xAxis = d3.svg.axis()
                  .scale(xScale)
                  .orient("bottom");</pre>
	<p>Наконец, собственно, для создания оси и вставки всех этих маленьких линий и меток внутрь нашего SVG, мы должны вызвать функцию xAxis методом call(). Я расположу этот код в конце нашего скрипта, так, чтобы ось была создана после создания всех остальных элементов в SVG:</p>
	<pre class="prettyprint linenums">svg.append("g").call(xAxis);</pre>
	<p>Функция call() библиотеки D3(https://github.com/mbostock/d3/wiki/Selections#call) принимает выборку в качестве входных данных, а потом передает ее любой функции. Так, в нашем случае, мы просто добавили новый групповой элемент g, чтобы хранить все элементы, которые будут сгенерированы для построения оси(Элемент g не является необходимым, но собирает элементы в кучу и позволяет нам применять css-классы, которые мы вскоре напишем).</p>
	<p>Этот элемент g становится выборкой для следующего метода в нашей цепочке вызовов функций. Метод call() берет эту выборку и передает ее функции xAxis, именно поэтому наша ось создается внутри нового элемента g. Фрагмент кода выше является хорошим, чистым и коротким, но мы сделаем для него эквивалентную запись:</p>
	<pre class="prettyprint linenums">
svg.append("g")
    .call(d3.svg.axis()
                .scale(xScale)
                .orient("bottom"));</pre>
	<p>Смотрите, вы могли бы втиснуть весь код функции оси внутри call(), но нам, как правило, проще сперва определить функцию, а лишь потом вызвать функцию. Так работают наши мозги. В любом случае, <a href="http://alignedleft.com/content/03-tutorials/01-d3/160-axes/1.html">результат выглядит так</a>:</p>
	<img src="images/axes_2.png" alt="Результат работы кода">
	<br/>
	<h3>Очистка</h3>
	<p>Вроде бы у нас получилась ось, но она не является ни красивой, ни полезной. Чтобы это исправить, давайте сначала назначим класс axis новому элементу g. Это мы можем сделать с помощью CSS:</p>
	<pre class="prettyprint linenums">
svg.append("g")
    .attr("class", "axis")  //Assign "axis" class
    .call(xAxis);</pre>
	<p>Дальше, мы напишем наш первый CSS-стиль. Для этого поднимитесь выше, к тегу <head> на нашей странице:</p>
	<pre class="prettyprint linenums">
.axis path,
.axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
}

.axis text {
    font-family: sans-serif;
    font-size: 11px;
}</pre>
	<p>Свойство <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering">shape-rendering</a> - это SVG-атрибут, используются нами для того, чтобы ось и отметки на ней выглядели превосходно. Никаких эффектов размытия для осей мы не наблюдаем!</p>
	<img src="images/axes_3.png" alt="Результат работы кода">
	<p>Уже лучше, но верхушка нашей оси несколько обрезана, но мы ее все равно хотим сместить к низу страницы. Мы можем использовать атрибут transform для всей группы элементов, представляющих ось(элемент g), чтобы расположить ось снизу:</p>
	<pre class="prettyprint linenums">
svg.append("g")
    .attr("class", "axis")
    .attr("transform", "translate(0," + (h - padding) + ")")
    .call(xAxis);</pre>
	<p>Обратите внимание, что использование (h - padding) устанавливает верхнюю границу нашей оси равной высоте всего изображения минут отступ(padding ), который мы задали ранее.</p>
	<img src="images/axes_4.png" alt="Результат работы кода">
	<p>Намного лучше! <a href="http://alignedleft.com/content/03-tutorials/01-d3/160-axes/2.html">Здесь представлен рабочий код.</a></p>
	<br/>
	<h3>Модифицируем отметки на нашей оси</h3>
	<p>Отметки на осях служат для передачи информации. Еще больше отметок не обязательно лучше, и в определенный момент они начинают загромождать диаграмму. Вы должны заметить, что мы нигде не указывали, сколько отметок должно быть на оси, и через какие промежутки они должны появляться. Без точных инструкций, D3 автомагически проверил нашу масштабирующую функцию xScale, и вывел обоснованные суждения о том, сколько меток должно быть, и через какие интервалы они расположены.</p>
	<p>Как вы можете себе представить, вы можете модифицировать все аспекты ваших осей. Начнем с грубого указания количества меток, используя метод ticks():</p>
	<pre class="prettyprint linenums">
var xAxis = d3.svg.axis()
                  .scale(xScale)
                  .orient("bottom")
                  .ticks(5);  //Set rough # of ticks</pre>
	<img src="images/axes_5.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/160-axes/3.html">Результат на этой странице.</a></p>
	<p>Вы, вероятно, заметили, что мы указали лишь пять меток, в то время как D3 нам нарисовал их целых семь. Это случилось потому, что D3 понял, что если использовать пять меток, то получатся невнятные интервалы 0, 150, 300, 450 и 600. D3 интерпретирует значение, переданное в метод ticks() как желаемое, но не обязательное, и переопределил ваше предложение по своему усмотрению, ориентируясь на удобочитаемость для человека, в нашем случае разделил шкалу на интервалы по 100. Именно поэтому эта функция является гениальной, поскольку увеличивает масштабируемость вашего графика. Если меняются значения набора данных и входная область значений сжимается или расширяется(большие числа или меньшие числа), D3 гарантирует, что метки делений по-прежнему удобны и понятны для чтения.</p>
	<br/>
	<h3>А как же ось Y?</h3>
	<p>Пришло время для создания вертикальной оси! Это мы сделаем путем копирования и настройки уже написанного кода для оси х:</p>
	<pre class="prettyprint linenums">
//Define Y axis
var yAxis = d3.svg.axis()
                  .scale(yScale)
                  .orient("left")
                  .ticks(5);</pre>
	<p>и размещаем ее слева:</p>
	<pre class="prettyprint linenums">
//Create Y axis
svg.append("g")
    .attr("class", "axis")
    .attr("transform", "translate(" + padding + ",0)")
    .call(yAxis);</pre>
	<p>Обратите внимание, что метки оси y будут находится слева от нее, и именно поэтому мы добавляем отступ padding, который уже был создан.</p>
	<img src="images/axes_6.png" alt="Результат работы кода">
	<p>Теперь график похож на настоящий! Но метки на yAxis обрезаются. Им надо предоставить больше пространства слева. Давайте увеличим нашу переменную отступа с 20 до 30:</p>
	<pre class="prettyprint linenums">var padding = 30;</pre>
	<p>Конечно, вы могли бы использовать отдельные переменные отступа для каждой оси координат для большей надежности, назвав их, например, xPadding и yPadding.</p>
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/160-axes/4.html">Здесь пример рабочего кода</a>, и вот как выглядит результат:</p>
	<img src="images/axes_7.png" alt="Результат работы кода">
	<br/>
	<h3>Последние штрихи</h3>
	<p>Для того, чтобы доказать вам, что наши оси масштабируемы, я сделаю так, чтобы начальная выборка создавалась путем добавления в нее случайных значений:</p>
	<pre class="prettyprint linenums">
//Dynamic, random dataset
var dataset = [];
var numDataPoints = 50;
var xRange = Math.random() * 1000;
var yRange = Math.random() * 1000;
for (var i = 0; i < numDataPoints; i++) {
    var newNumber1 = Math.round(Math.random() * xRange);
    var newNumber2 = Math.round(Math.random() * yRange);
    dataset.push([newNumber1, newNumber2]);
}</pre>
	<p>Этот код инициализирует пустой массив, потом 50 раз подряд генерирует два случайных числа, и добавляет эту пару в наш массив, представляющий собой набор данных.</p>
	<img src="images/axes_8.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/160-axes/5.html">Этот код находится здесь.</a> Каждый раз при перезагрузке страницы, вы будете получить различные наборы данных. Обратите внимание, как обе оси масштабируются в соответствии с новой областью входных данных, также как и отметки и метки.</p>
	<p>И наконец, я думаю, мы можем избавиться от этих ужасных красных меток, закомментировав необходимые строки кода:</p>
	<img src="images/axes_9.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/160-axes/6.html">Конечный вид нашей точечной диаграммы!</a></p>
	<br/>
	<h3>Форматирование наших отметок</h3>
	<p>Одна последняя вещь: когда мы работаем с целыми числами - все очень приятно и красиво. Но данные обычно грязнее, и в этих случаях требуется больший контроль над тем, как форматируются метки на осях. Например, вы можете включить три знака после запятой, или отображение значений в процентах, или оба варианта.</p>
	<p>В этом случае, вы могли бы сначала определить новый номер функции форматирования. Это, например, говорит, чтобы значение преобразовывалось в проценты с одним числом после запятой(для более близкого знакомства см. документацию <a href="https://github.com/mbostock/d3/wiki/Formatting#d3_format">d3.format()</a>).</p>
	<pre class="prettyprint linenums">var formatAsPercentage = d3.format(".1%");</pre>
	<p>Сделаем, чтобы это форматирование было использовано для меток для оси х:</p>
	<pre class="prettyprint linenums">xAxis.tickFormat(formatAsPercentage);</pre>
	<p>Подсказка: проще всего проверить результат работы кода в консоли JavaScript. Например, достаточно открыть любую страницу, которая загружает D3, например конечную версию нашей точечной диаграммы, и ввести в консоль на той странице ваши правила форматирования. Затем, проверьте функцию, передавая ей разные значения на вход:</p>
	<img src="images/axes_10.png" alt="Результат работы кода">
	<p>Вы можете видеть, как числа 0.54321 преобразовано в 54.3%. Для целей наглядного отображения - превосходно!</p>
		</div>
	</body>
</html>
