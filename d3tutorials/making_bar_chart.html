<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<link rel="stylesheet" href="css/metro-bootstrap.css">
		<link rel="stylesheet" href="css/metro-bootstrap-responsive.css">
		<link rel="stylesheet" href="css/iconFont.css">
		<link rel="stylesheet" href="js/prettify/prettify.css">

        <script src="js/jquery/jquery.min.js"></script>
        <script src="js/jquery/jquery.widget.min.js"></script>
        <script src="js/jquery/jquery.mousewheel.js"></script>
		<script src="js/prettify/prettify.js"></script>
        <script src="js/metro/metro.min.js"></script>
		
		<script src="js/docs.js"></script>
		<script src="js/github.info.js"></script>
		<script type="text/javascript">
			var lNavigationDescriptor_obj_arr = [
				{
					pageName : "about.html",
					description : "Об этом руководстве",
					prevPageName : "",
					nextPageName : "fundamentals.html"
				},
				{
					pageName : "fundamentals.html",
					description : "Основы",
					prevPageName : "about.html",
					nextPageName : "setup.html"
				},
				{
					pageName : "setup.html",
					description : "Установка",
					prevPageName : "fundamentals.html",
					nextPageName : "adding_elements.html"
				},
				{
					pageName : "adding_elements.html",
					description : "Добавление элементов",
					prevPageName : "setup.html",
					nextPageName : "chaining_methods.html"
				},
				{
					pageName : "chaining_methods.html",
					description : "Цепочки методов",
					prevPageName : "adding_elements.html",
					nextPageName : "binding_data.html"
				},
				{
					pageName : "binding_data.html",
					description : "Привязка данных",
					prevPageName : "chaining_methods.html",
					nextPageName : "using_your_data.html"
				},
				{
					pageName : "using_your_data.html",
					description : "Использование данных",
					prevPageName : "binding_data.html",
					nextPageName : "drawing_divs.html"
				},
				{
					pageName : "drawing_divs.html",
					description : "Рисование с использованием блоков",
					prevPageName : "using_your_data.html",
					nextPageName : "power_of_data.html"
				},
				{
					pageName : "power_of_data.html",
					description : "Сила метода data()",
					prevPageName : "drawing_divs.html",
					nextPageName : "svg_primer.html"
				},
				{
					pageName : "svg_primer.html",
					description : "Пример с использованием SVG",
					prevPageName : "power_of_data.html",
					nextPageName : "drawing_svgs.html"
				},
				{
					pageName : "drawing_svgs.html",
					description : "Рисование с использованием SVG-элементов",
					prevPageName : "svg_primer.html",
					nextPageName : "types_of_data.html"
				},
				{
					pageName : "types_of_data.html",
					description : "Типы данных",
					prevPageName : "drawing_svgs.html",
					nextPageName : "making_bar_chart.html"
				},
				{
					pageName : "making_bar_chart.html",
					description : "Делаем столбиковую диаграмму",
					prevPageName : "types_of_data.html",
					nextPageName : "making_scatterplot.html"
				},
				{
					pageName : "making_scatterplot.html",
					description : "Делаем точечную диаграмму",
					prevPageName : "making_bar_chart.html",
					nextPageName : "scales.html"
				},
				{
					pageName : "scales.html",
					description : "Масштабирование",
					prevPageName : "making_scatterplot.html",
					nextPageName : "axes.html"
				},
				{
					pageName : "axes.html",
					description : "Координатные оси",
					prevPageName : "scales.html",
					nextPageName : ""
				}
			];
			
			function getPageProperty(aPageName_str, aPropertyName_str) {
				var lPagesCount_int = lNavigationDescriptor_obj_arr.length;
				for (var i = 0; i < lPagesCount_int; i++) {
					var lPageDescriptor_obj = lNavigationDescriptor_obj_arr[i];
					var lPGPageName_str = lPageDescriptor_obj.pageName;
					if (aPageName_str === lPGPageName_str) {
						return lPageDescriptor_obj[aPropertyName_str];
					}
				}
				return "";
			}
			
			window.onload = function () {
				var lPageName_str = location.href.match(/[^/]+\.html/i)[0];
				var lPagesCount_int = lNavigationDescriptor_obj_arr.length;
				for (var i = 0; i < lPagesCount_int; i++) {
					var lPageDescriptor_obj = lNavigationDescriptor_obj_arr[i];
					var lPGPageName_str = lPageDescriptor_obj.pageName;
					if (lPageName_str === lPGPageName_str) {
						var lPGPrevPageName_str = lPageDescriptor_obj.prevPageName;
						var lPGPrevPageDescription_str = getPageProperty(lPGPrevPageName_str, "description");
						var lPGNextPageName_str = lPageDescriptor_obj.nextPageName;
						var lPGNExtPageDescription_str = getPageProperty(lPGNextPageName_str, "description");
						
						var lNav_e = $("#navigation");
						
						if (lPGPrevPageName_str.trim().length > 0) {
							var lPrevPageNav_e = $("<div class=\"span4\" align=\"center\"/>");
							var lLinkText_str = "<i class=\"icon-arrow-left-3\"></i>&nbsp;" + lPGPrevPageDescription_str;
							var lLink_e = $("<a class=\"seganav\" />").attr("href", lPGPrevPageName_str).html(lLinkText_str);
							lPrevPageNav_e.append(lLink_e);
							lNav_e.append(lPrevPageNav_e);
						}
						
						var lContentPageNav_e = $("<div align=\"center\"/>");
						if (lPGPrevPageName_str.trim().length > 0) {
							lContentPageNav_e.addClass("span4");
						} else {
							lContentPageNav_e.addClass("span4 offset4");
						}
						var lLinkText_str = "<i class=\"icon-book\"></i>&nbsp;" + "Оглавление";
						var lLink_e = $("<a class=\"seganav\" />").attr("href", "index.html").html(lLinkText_str);
						lContentPageNav_e.append(lLink_e);
						lNav_e.append(lContentPageNav_e);
						
						if (lPGNextPageName_str.trim().length > 0) {
							var lNextPageNav_e = $("<div class=\"span4\" align=\"center\"/>");
							var lLinkText_str = lPGNExtPageDescription_str + "&nbsp;<i class=\"icon-arrow-right-3\"></i>";
							var lLink_e = $("<a class=\"seganav\" />").attr("href", lPGNextPageName_str).html(lLinkText_str);
							lNextPageNav_e.append(lLink_e);
							lNav_e.append(lNextPageNav_e);
						}
						break;
					}
				}
				if (lPageName_str === "index.html") {
					$("#navigation").hide();
				}
			};
		</script>
		<title>Делаем столбиковую диаграмму</title>
	</head>
	<body class="metro">
		<div class="container">
			<div class="grid">
				<div class="row">
					<div class="span12">
						<div align="center">
		<h1>Делаем столбиковую диаграмму</h1>
	</div>
	<br/>
	<p>Теперь мы объединим все, что мы изучили в этом руководстве и сгенерируем простую столбиковую диаграмму с использованием D3.</p>
	<p>Мы начнем с обзора столбиковой диаграммы, которую мы реализовали с использованием блоков. Потом мы будем использовать этот код для реализации столбиковой диаграммы с использованием SVG-элементов, что даст нам больше гибкости для построения визуальных образов. И в конце мы добавим надписи, указывающие значения на столбиках, чтобы все было предельно понятно.</p>
	<br/>
	<h3>Старая диаграмма</h3>
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/1.html">Здесь то, что у нас получилось в прошлый раз, только использован другой набор данных.</a></p>
	<pre class="prettyprint linenums">
var dataset = [ 5, 10, 13, 19, 21, 25, 22, 18, 15, 13,
                11, 12, 15, 20, 18, 17, 16, 18, 23, 25 ];
d3.select("body").selectAll("div")
    .data(dataset)
    .enter()
    .append("div")
    .attr("class", "bar")
    .style("height", function(d) {
        var barHeight = d * 5;
        return barHeight + "px";
    });</pre>
	<img src="images/making_bar_chart_1.png" alt="Результат работы кода">
	<p>Сложно представить, но мы можем основательно преобразить этот простой график с использованием блоков.</p>
	<br/>
	<h3>Новая диаграмма</h3>
	<p>Изначально надо определиться с размерами SVG.</p>
	<pre class="prettyprint linenums">
//Width and height
var w = 500;
var h = 100;</pre>
	<p>(Конечно, вы можете переменные w и h назвать по-другому, например svgWidth и svgHeight. Используйте то, что более понятно вам. На JavaScript принято писать эффективный код, поэтому вы часто будете видеть имена переменных в одну букву, код без пробелов, и всякий разный код, который невероятно сложно читать, зато более эффективный.)</p>
	<p>Дальше мы говорим D3 создать пустой SVG-элементов и добавляем его в DOM:</p>
	<pre class="prettyprint linenums">
//Create SVG element
var svg = d3.select("body")
            .append("svg")
            .attr("width", w)
            .attr("height", h);</pre>
	<p>Код выше добавляет новый <i>&lt;svg&gt;</i> элемент перед закрывающимся тегом </body> и определяет ширину 500 и высоту 100 пикселей. Также этот код присваивает переменной svg результат выполнения. Это сделано для того, чтобы мы имели быстрый доступ к новому созданному SVG-элементу без каких-либо дополнительных манипуляций типа d3.select("svg").</p>
	<p>Дальше вместо создания блоков, мы создаем прямоугольники и добавляем их к svg.</p>
	<pre class="prettyprint linenums">
svg.selectAll("rect")
   .data(dataset)
   .enter()
   .append("rect")
   .attr("x", 0)
   .attr("y", 0)
   .attr("width", 20)
   .attr("height", 100);</pre>
	<p>Этот код выбирает все прямоугольники, расположенные внутри svg. Конечно, в SVG еще нет никаких элементов, поэтому возвращается пустое выделение.(Странно, да, но наберитесь терпения. В D3 надо сначала сделать выборку с чем работать, даже если эта выборка изначально будет пустой.)</p>
	<p>Дальше метод data(dataset) видит, что у нас в наборе данных 20 значений, поэтому следующий метод enter() вызывается 20 раз. enter() , наоборот, возвращает некоторый шаблон для каждого значения, который ничего общего пока не имеет с прямоугольником.</p>
	<p>Дальше для каждого шаблона методом append("rect") добавляется элемент rect в DOM. Как мы уже знаем, каждый rect должен иметь заданные атрибуты x,y,width и height. Мы используем метод attr() для добавления соответствующему элементу rect необходимые атрибуты.</p>
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/2.html">Красиво, нет?</a></p>
	<img src="images/making_bar_chart_2.png" alt="Результат работы кода">
	<p>Ок, может и нет. Все наши столбики на месте(Проверьте DOM в веб-инспекторе на <a href="http://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/2.html">демо-странице</a>), но все столбики имеют одни и те же значения для атрибутов x,y,width,height, так что в итоге они наложены друг на друга. Сейчас это вообще не выглядит визуализацией данных.</p>
	<p>Давайте первоначально исправим наложение столбиков. Вместо того, чтобы в атрибут x rect'ов вписывать 0, мы будем вписывать динамическое значение, которое будет рассчитываться из i, то есть из порядкового номера текущего значения в наборе данных. Первому столбику в i будет соответствовать 0, и его атрибут x будет иметь значение 0; у второго столбика i=1, и его атрибут х будет иметь значение 21. У третьего столбика атрибут х будет равен 42, и т.д.</p>
	<pre class="prettyprint linenums">
.attr("x", function(d, i) {
	return i * 21;  //Bar width of 20 plus 1 for padding
})</pre>
	<img src="images/making_bar_chart_3.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/3.html">На этой странице пример нашего кода.</a></p>
	<p>Этот код работает, но он не особенно гибкий. Если наш набор данных будет содержать намного больше значений, столбики не поместятся на нашем SVG, и будут отрисовываться за его пределами, а мы их не будем видеть. Так как один столбик шириной 20 пикселей + 1 пиксель расстояние между столбиками, то на SVG шириной в 500 пикселей может отобразиться 23 столбика(что соответствует 23м значениям в начальном наборе данных). Обратите внимание, как 24й столбик будет обрезан:</p>
	<img src="images/making_bar_chart_4.png" alt="Результат работы кода">
	<p>Существует хорошая практика рассчитывать width, height, x, y динамически, что позволит вашей визуализации быть более гибкой и масштабироваться в соответствии с вашим первоначальным набором данных.</p>
	<p>Как и все остальное в программировании, есть 1000 путей для достижения этого результата. Я буду использовать один простой способ. Первоначально я изменю строку кода, где рассчитывается позиция х каждого столбика:</p>
	<pre class="prettyprint linenums">
.attr("x", function(d, i) {
    return i * (w / dataset.length);
})</pre>
	<p>Обратите внимание, как значение х теперь привязано непосредственно в ширине SVG и количеству значений в наборе данных(dataset.length). Как же здорово, что теперь наши столбики равномерно удалены друг от друга и распределены по всей ширине SVG, и без разницы, имеем ли 20 значений в наборе данных:</p>
	<img src="images/making_bar_chart_5.png" alt="Результат работы кода">
	<p>или 5 значений:</p>
	<img src="images/making_bar_chart_6.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/4.html">На этой странице представлен работающий код.</a></p>
	<p>Теперь мы должны сделать так, чтобы ширина столбика тоже динамически вычислялась в зависимости от ширины SVG и количества значений в наборе данных. Я добавлю новую переменную рядом с местом, где мы задаем ширину и высоту SVG:</p>
	<pre class="prettyprint linenums">
//Width and height
var w = 500;
var h = 100;
var barPadding = 1;  // <-- New!</pre>
	<p>и далее буду использовать эту новую переменную в месте, где мы рассчитываем ширину столика. Вместо статического значения в 20 пикселей, ширина столбика будет рассчитываться по такой формуле:</p>
	<pre class="prettyprint linenums">.attr("width", w / dataset.length - barPadding)</pre>
	<img src="images/making_bar_chart_7.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/5.html">Работает!</a> Ширина столбиков и их позиция масштабируются правильно, будь в наборе данных 20 значений, или только пять:</p>
	<img src="images/making_bar_chart_8.png" alt="Результат работы кода">
	<p>или даже сто:</p>
	<img src="images/making_bar_chart_9.png" alt="Результат работы кода">
	<p>И в конце, мы поставим в зависимость высоту каждого столбика от величины соответствующего ему значения в наборе данных. Вы, наверное, надеетесь, что мы просто приравняем высоту нашего столбика к величине соответствующего ему значения:</p>
	<pre class="prettyprint linenums">
.attr("height", function(d) {
    return d;
});</pre>
	<img src="images/making_bar_chart_10.png" alt="Результат работы кода">
	<p>Выглядит фигово. Может, мы просто умножим наши значения на некоторое постоянное значение?</p>
	<pre class="prettyprint linenums">
.attr("height", function(d) {
    return d * 4;  // <-- Times four!
});</pre>
	<img src="images/making_bar_chart_11.png" alt="Результат работы кода">
	<p>Увы, это не так-то просто - мы хотим, чтобы наши столбики росли с нижней границы вверх, а не наоборот. Но не вините в этом D3, все дело в SVG.</p>
	<p>Вспомните про SVG-примеры ранее: когда мы рисуем прямоугольник, значения x и y определяют координаты верхнего левого угла. То есть точкой отчета для каждого прямоугольника является верхний левый угол. Нам было бы проще, конечно, установить точку отсчета с левого нижнего угла, но так SVG сделать не может, так как ему пофиг на то, чего хотите вы.</p>
	<p>Учитывая то, что наши столбики растут сверху вниз, то как связать вершину нашего столбика с высотой SVG? Вершина каждого столбика может быть выражена как связь между высотой SVG и значением, соответствующем столбику, как показано ниже:</p>
	<pre class="prettyprint linenums">
.attr("y", function(d) {
    return h - d;  //Height minus data value
})</pre>
	<p>Далее, чтобы начало столбиков было внизу, высоту каждого столбика приравниваем к значению из набора данных:</p>
	<pre class="prettyprint linenums">
.attr("height", function(d) {
    return d;  //Just the data value
});</pre>
	<img src="images/making_bar_chart_12.png" alt="Результат работы кода">
	<p>А теперь, давайте увеличим высоту каждого столбика в 4 раза(Позже я научу, как делать масштабирование с использованием D3, потому что он более удобен):</p>
	<img src="images/making_bar_chart_13.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/6.html">На этой странице представлен работающий код.</a></p>
	<br/>
	<h3>Цвета</h3>
	<p>Добавление цвета является простой процедурой: используем метод  attr()и задаем атрибут fill:</p>
	<pre class="prettyprint linenums">.attr("fill", "teal");</pre>
	<img src="images/making_bar_chart_14.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/7.html">Получившийся результат тут.</a> Правда, обычно надо, чтобы цвет зависел от значения в наборе данных. Можно закодировать значение в наборе как цвет(в контексте нашего примера получится, что он одного значения зависит и высота столбика и его цвет).</p>
	<p>Для использования данных для управления цветом проще всего написать дополнительную функцию, которая ссылалась бы на d:</p>
	<pre class="prettyprint linenums">
.attr("fill", function(d) {
    return "rgb(0, 0, " + (d * 10) + ")";
});</pre>
	<img src="images/making_bar_chart_15.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/8.html">Вот результат.</a> Это не особенно популярная методика привязки данных к цвету, но вам, думаю, этот пример полезен. В нашем примере d умножается на 10, и потом устанавливается значения синего цвета в RGB-кодировании. Поэтому, чем больше d, тем столбик будет выше и заполнен более синим цветом. Чем меньше d, тем столбик будет ниже, а его цвет будет более близок к черному.</p>
	<br/>
	<h3>Метки</h3>
	<p>Визуализация превосходна! Но иногда надо показать текущее значение в виде текста вместе с визуальным представлением. Для этого мы используем метки, которые очень просто генерируются с помощью D3.</p>
	<p>Давайте вспомним SVG пример, когда мы добавляли в нем текстовые элементы:</p>
	<pre class="prettyprint linenums">
svg.selectAll("text")
   .data(dataset)
   .enter()
   .append("text")</pre>
	<p>Знакомо? То, что мы делали для rect, теперь делаем и для text. Сперва делаем выборку, ассоциируем ее с набором данных, добавляем шаблонные элементы, а потом эти шаблонные элементы заменяем text-элементами.</p>
	<p>Мы расширим тот код и сделаем так, чтобы в каждом текстовом поле отображалось ассоциированное значение в наборе данных(будем использовать метод text()):</p>
	<pre class="prettyprint linenums">
.text(function(d) {
        return d;
   })</pre>
	<p>а потом еще больше расширим, добавив атрибуты x и y для позиционирования текста. Проще всего это сделать путем копи-паста предыдущего кода для установки координат для столбиков:</p>
	<pre class="prettyprint linenums">
.attr("x", function(d, i) {
        return i * (w / dataset.length);
   })
   .attr("y", function(d) {
        return h - (d * 4);
   });</pre>
	<img src="images/making_bar_chart_16.png" alt="Результат работы кода">
	<p>Ага! метки значений! Но некоторые сверху попросту обрезаны. Давайте переместим метки немного ниже, чтобы они были расположены внутри столбиков:</p>
	<pre class="prettyprint linenums">
.attr("x", function(d, i) {
        return i * (w / dataset.length) + 5;  // +5
   })
   .attr("y", function(d) {
        return h - (d * 4) + 15;              // +15
   });</pre>
	<img src="images/making_bar_chart_17.png" alt="Результат работы кода">
	<p>Лучше, но теперь текст не всегда разборчив. Конечно же, мы это можем исправить:</p>
	<pre class="prettyprint linenums">
.attr("font-family", "sans-serif")
   .attr("font-size", "11px")
   .attr("fill", "white");</pre>
	<img src="images/making_bar_chart_18.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/9.html">Фантастика!</a> Вполне симпотно, значит готово. Хотя, возможно, вы заметили, что надписи расположены не вполне по центру внутри своих столбиков. Это очень просто исправить. Будем использовать SVG-атрибут text-anchor для горизонтального центрирования текста относительно позиции x.</p>
	<pre class="prettyprint linenums">.attr("text-anchor", "middle")</pre>
	<p>Теперь изменим код рассчета позиции х для текста. Мы будем делить ширину столбика пополам и прибавлять полученное значение к начальной координате х столбика, тем самым получим его центр:</p>
	<pre class="prettyprint linenums">
.attr("x", function(d, i) {
        return i * (w / dataset.length) + (w / dataset.length - barPadding) / 2;
    })</pre>
	<p>Также я изменю позицию на пиксель, ну чтобы вообще первоклассно все выглядело:</p>
	<pre class="prettyprint linenums">
.attr("y", function(d) {
        return h - (d * 4) + 14;  //15 is now 14
    })</pre>
	<img src="images/making_bar_chart_19.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/130-making-a-bar-chart/10.html">Готово!</a> На этом давайте закончим со столбиковыми диаграммами.</p>
						
						<div class="row bg-cyan" id="navigation" style="padding: 20px 0">
						</div>
					</div>
				</div>
			</div>
		</div>
	</body>
</html>
