<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="description" content="Визуализация данных, пошаговое руководство, книга по D3" />
		<meta name="keywords" content="code, art, design, data, visualization, generative, algorithmic, processing, d3, d3.js, book, maps, код, данные, искусство, визуализация, обработка данных, книга, отображение данных" />
		<meta name="author" content="Иванов Сергей" />
	
		<link rel="stylesheet" href="css/metro-bootstrap.css">
		<link rel="stylesheet" href="css/metro-bootstrap-responsive.css">
		<link rel="stylesheet" href="css/iconFont.css">
		<link rel="stylesheet" href="js/prettify/prettify.css">

        <script src="js/jquery/jquery.min.js"></script>
        <script src="js/jquery/jquery.widget.min.js"></script>
        <script src="js/jquery/jquery.mousewheel.js"></script>
		<script src="js/prettify/prettify.js"></script>
        <script src="js/metro/metro.min.js"></script>
		
		<script src="js/docs.js"></script>
		<script src="js/github.info.js"></script>
		<script type="text/javascript">
			var lNavigationDescriptor_obj_arr = [
				{
					pageName : "about.html",
					description : "Об этом руководстве",
					prevPageName : "",
					nextPageName : "fundamentals.html"
				},
				{
					pageName : "fundamentals.html",
					description : "Основы",
					prevPageName : "about.html",
					nextPageName : "setup.html"
				},
				{
					pageName : "setup.html",
					description : "Установка",
					prevPageName : "fundamentals.html",
					nextPageName : "adding_elements.html"
				},
				{
					pageName : "adding_elements.html",
					description : "Добавление элементов",
					prevPageName : "setup.html",
					nextPageName : "chaining_methods.html"
				},
				{
					pageName : "chaining_methods.html",
					description : "Цепочки методов",
					prevPageName : "adding_elements.html",
					nextPageName : "binding_data.html"
				},
				{
					pageName : "binding_data.html",
					description : "Привязка данных",
					prevPageName : "chaining_methods.html",
					nextPageName : "using_your_data.html"
				},
				{
					pageName : "using_your_data.html",
					description : "Использование данных",
					prevPageName : "binding_data.html",
					nextPageName : "drawing_divs.html"
				},
				{
					pageName : "drawing_divs.html",
					description : "Рисование с использованием блоков",
					prevPageName : "using_your_data.html",
					nextPageName : "power_of_data.html"
				},
				{
					pageName : "power_of_data.html",
					description : "Сила метода data()",
					prevPageName : "drawing_divs.html",
					nextPageName : "svg_primer.html"
				},
				{
					pageName : "svg_primer.html",
					description : "Пример с использованием SVG",
					prevPageName : "power_of_data.html",
					nextPageName : "drawing_svgs.html"
				},
				{
					pageName : "drawing_svgs.html",
					description : "Рисование с использованием SVG-элементов",
					prevPageName : "svg_primer.html",
					nextPageName : "types_of_data.html"
				},
				{
					pageName : "types_of_data.html",
					description : "Типы данных",
					prevPageName : "drawing_svgs.html",
					nextPageName : "making_bar_chart.html"
				},
				{
					pageName : "making_bar_chart.html",
					description : "Делаем столбиковую диаграмму",
					prevPageName : "types_of_data.html",
					nextPageName : "making_scatterplot.html"
				},
				{
					pageName : "making_scatterplot.html",
					description : "Делаем точечную диаграмму",
					prevPageName : "making_bar_chart.html",
					nextPageName : "scales.html"
				},
				{
					pageName : "scales.html",
					description : "Масштабирование",
					prevPageName : "making_scatterplot.html",
					nextPageName : "axes.html"
				},
				{
					pageName : "axes.html",
					description : "Координатные оси",
					prevPageName : "scales.html",
					nextPageName : ""
				}
			];
			
			function getPageProperty(aPageName_str, aPropertyName_str) {
				var lPagesCount_int = lNavigationDescriptor_obj_arr.length;
				for (var i = 0; i < lPagesCount_int; i++) {
					var lPageDescriptor_obj = lNavigationDescriptor_obj_arr[i];
					var lPGPageName_str = lPageDescriptor_obj.pageName;
					if (aPageName_str === lPGPageName_str) {
						return lPageDescriptor_obj[aPropertyName_str];
					}
				}
				return "";
			}
			
			window.onload = function () {
				var lPageName_str = location.href.match(/[^/]+\.html/i)[0];
				var lPagesCount_int = lNavigationDescriptor_obj_arr.length;
				for (var i = 0; i < lPagesCount_int; i++) {
					var lPageDescriptor_obj = lNavigationDescriptor_obj_arr[i];
					var lPGPageName_str = lPageDescriptor_obj.pageName;
					if (lPageName_str === lPGPageName_str) {
						var lPGPrevPageName_str = lPageDescriptor_obj.prevPageName;
						var lPGPrevPageDescription_str = getPageProperty(lPGPrevPageName_str, "description");
						var lPGNextPageName_str = lPageDescriptor_obj.nextPageName;
						var lPGNExtPageDescription_str = getPageProperty(lPGNextPageName_str, "description");
						
						var lTopNav_e = $("#top_navigation");
						var lBottomNav_e = $("#bottom_navigation");
						
						if (lPGPrevPageName_str.trim().length > 0) {
							var lPrevPageNav_e = $("<div class=\"span4\" align=\"center\"/>");
							var lLinkText_str = "<i class=\"icon-arrow-left-3\"></i>&nbsp;" + lPGPrevPageDescription_str;
							var lLink_e = $("<a class=\"seganav\" />").attr("href", lPGPrevPageName_str).html(lLinkText_str);
							lPrevPageNav_e.append(lLink_e);
							var lCopyPrevPageNav_e = lPrevPageNav_e.clone();
							lBottomNav_e.append(lPrevPageNav_e);
							lTopNav_e.append(lCopyPrevPageNav_e);
						}
						
						var lContentPageNav_e = $("<div align=\"center\"/>");
						if (lPGPrevPageName_str.trim().length > 0) {
							lContentPageNav_e.addClass("span4");
						} else {
							lContentPageNav_e.addClass("span4 offset4");
						}
						var lLinkText_str = "<i class=\"icon-book\"></i>&nbsp;" + "Оглавление";
						var lLink_e = $("<a class=\"seganav\" />").attr("href", "index.html").html(lLinkText_str);
						lContentPageNav_e.append(lLink_e);
						var lCopyContentPageNav_e = lContentPageNav_e.clone();
						lBottomNav_e.append(lContentPageNav_e);
						lTopNav_e.append(lCopyContentPageNav_e);
						
						if (lPGNextPageName_str.trim().length > 0) {
							var lNextPageNav_e = $("<div class=\"span4\" align=\"center\"/>");
							var lLinkText_str = lPGNExtPageDescription_str + "&nbsp;<i class=\"icon-arrow-right-3\"></i>";
							var lLink_e = $("<a class=\"seganav\" />").attr("href", lPGNextPageName_str).html(lLinkText_str);
							lNextPageNav_e.append(lLink_e);
							var lCopyNextPageNav_e = lNextPageNav_e.clone();
							lBottomNav_e.append(lNextPageNav_e);
							lTopNav_e.append(lCopyNextPageNav_e);
						}
						break;
					}
				}
				if (lPageName_str !== "index.html") {
					$("#top_navigation").show();
					$("#bottom_navigation").show();
				}
			};
		</script>
		<title>Масштабирование</title>
	</head>
	<body class="metro">
		<div class="container">
			<div class="grid">
				<div class="row">
					<div class="span12">
						<div class="row bg-cyan" id="top_navigation" style="padding: 20px 0; display: none;">
						</div>
						
						<div align="center">
		<h1>Масштабирование</h1>
	</div>
	<br/>
	<p>"Масштабирование - это функция, которая преобразует входной набор данных в выходной набор в заданном диапазоне."</p>
	<p><a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales">Так описал термин "масштабирование" Майк Босток применительно к D3.</a></p>
	<p>Значения в любом наборе данных вряд ли будут соответствовать в точности для вашей визуализации. Масштабирование обеспечивает удобный способ сопоставления входного набора данных и данных, которые будут участвовать в вашей визуализации.</p>
	<p>Масштабированием в D3 занимаются функции, параметры которых определяете именно вы. Однажды создав функцию масштабирования, вы ее вызываете каждый раз каждый раз, когда получаете набор данных, а она вам возвращает красиво масштабированные выходные значения. Вы можете определить и не одну такую функцию.</p>
	<p>Возможно, это очень заманчиво думать, что масштабирование - это что-то визуальное, появляющееся на окончательном изображении, как, например, набор делений с указанием последовательности значений. Не обманывайте себя! Эти метки являются частью оси, являющиеся, по сути, наглядным воплощением масштабирования. Масштабирование - это математическое отношение, без конкретного визуального представления. Я призываю вас считать масштабирование и наглядное представление на осях взаимосвязанными, но все же разными понятиями.</p>
	<p>Это все касается линейного масштабирования, так как это самое простое и понятное. Однако, поняв принцип, вы сможете легко понять и нелинейное масштабирование.</p>
	<br/>
	<h3>Яблоки и пиксели</h3>
	<p>Представьте, что следующий набор данных показывает количество проданных яблок ларька, расположенного на обочине дороги, по месяцам:</p>
	<pre class="prettyprint linenums">var dataset = [ 100, 200, 300, 400, 500 ];</pre>
	<p>Сначала хорошая новость: каждый месяц ларек продает на сто яблок больше, чем в предыдущем месяце! Взрывной бизнес. Чтобы продемонстрировать этот успех, вы хотите сделать столбиковую диаграмму, иллюстрирующую крутой подъем продажи яблок, где каждому значению проданных яблок соответствует высота одного из столбиков на диаграмме.</p>
	<p>До сих пор, мы использовали значения данных напрямую в визуальных параметрах. Так, если было продано 500 яблок, соответствующий столбик будет 500 пикселей в высоту.</p>
	<p>Это может сработать, но что насчет следующего месяца, когда будут проданы 600 яблок? А годом позже, когда будет продано 1800 яблок? Ваша аудитория должна будет приобретать дисплеи большего размера, только для того, чтобы видеть всю высоту этих ваших столбиков с проданными яблоками!</p>
	<p>Это как раз тот случай, когда нам поможет масштабирование. Так как яблоки не являются пикселями(так же как и апельсинами), нам нужна масштабирующая функция для сопоставления проданным яблокам высоту в пикселях.</p>
	<br/>
	<h3>Области и диапазоны</h3>
	<p>Входная область данных для масштабируемой функции является диапазоном допустимых входных значений. Учитывая пример с яблоками выше, соответствующая входная область будет либо 100-500(минимальное и максимальное значение набора данных), либо 0-500.</p>
	<p>Выходной диапазон в масштабируемой функции - это диапазон возможных выходных значений, обычно используемый для вывода на дисплей в пикселях. Выходной диапазон выбирается полностью на ваше усмотрение. Если вы решите, что самый низкий столбик с яблоками будет 10 пикселей в высоту, а самый высокий 350 пикселей, то вы можете установить выходной диапазон 10 и 350 пикселей.</p>
	<p>Например, сделаем масштабирующую функцию с входной областью данных 100-500, и выходной диапазон значений. Если бы вы дали нашей функции на вход 100, но выходе получили бы 10. Если бы вы дали на вход 500, но выходе получили бы 350. Если на входе 300, то на выходе 180 получите и распишитесь(300 - это середина входной области данных, а 180 середина выходного диапазона).</p>
	<p>Мы можем отобразить входную область данных и выходной диапазон значений так:</p>
	<svg width="505" height="115">
		<text x="220" y="15" font-style="italic">Input domain</text>
		<line x1="5" y1="30" x2="500" y2="30" stroke="gray" stroke-width="1"/>
		<circle cx="5" cy="30" r="3" fill="#008"/>
		<text x="8" y="48">100</text>
		<circle cx="255" cy="30" r="3" fill="#008"/>
		<text x="258" y="48">300</text>
		<circle cx="500" cy="30" r="3" fill="#008"/>
		<text x="473" y="48">500</text>
		<line x1="5" y1="90" x2="500" y2="90" stroke="gray" stroke-width="1"/>
		<circle cx="5" cy="90" r="3" fill="#008"/>
		<text x="8" y="84">10</text>
		<circle cx="255" cy="90" r="3" fill="#008"/>
		<text x="258" y="84">180</text>
		<circle cx="500" cy="90" r="3" fill="#008"/>
		<text x="473" y="84">350</text>
		<text x="220" y="110" font-style="italic">Output range</text>
	</svg>
	<p>Еще одна вещь: не стоит путать эти два понятия входной диапазон данных и выходной диапазон значений.</p>
	<br/>
	<h3>Нормализация</h3>
	<p>Если вы знакомы с концепцией нормализации, может быть полезным вам знать, как все происходит в нашем примере на самом деле.</p>
	<p>Нормализацией является процесс преобразования числовых значений в новые значения в диапазоне от 0 до 1, основываясь на минимальном и максимальном начальных значениях. Например, в году 365 дней. 310й день в году это около 0.85 года, или если в процентах, то 85%.</p>
	<p>Если масштабирование является линейным, мы используем D3 и позволяем ему управлять математическим процессом нормализации. Входные значения нормализуются в соответствии с входной областью значений, а далее нормализованные значения масштабируются в выходной диапазон.</p>
	<br/>
	<h3>Реализуем масштабирование</h3>
	<p>Генератор масштабируемых функций в D3 доступен по адресу <i>d3.scale</i>, где далее указываете необходимую вам масштабируемую функцию.</p>
	<pre class="prettyprint linenums">var scale = d3.scale.linear();</pre>
	<p>Мои поздравления! Теперь <i>scale</i> - это функция, через которую вы можете пропускать входные значения(Помните, в JavaScript переменные могут хранить также и функции).</p>
	<pre class="prettyprint linenums">scale(2.5);  //Returns 2.5</pre>
	<p>Так как у нас нет еще входной области значений и выходного диапазона значений, эта функция масштабирует входные значения к выходным в пропорции 1:1. Это значит, что какое бы значение мы ни передали в функцию, она вернет его же.</p>
	<p>Мы можем задать входную область значений 100-500, передавая эти значения в метод <i>domain()</i> в качестве массива:</p>
	<pre class="prettyprint linenums">scale.domain([100, 500]);</pre>
	<p>Также мы устанавливаем выходной диапазон вызовом метода <i>range()</i>:</p>
	<pre class="prettyprint linenums">scale.range([10, 350]);</pre>
	<p>Эти шаги могут быть сделаны отдельно, как сделаны выше, или мы можем использовать цепочки вызовов:</p>
	<pre class="prettyprint linenums">
var scale = d3.scale.linear()
                    .domain([100, 500])
                    .range([10, 350]);</pre>
	<p>В любом случае, наша масштабирующая функция готова к использованию!</p>
	<pre class="prettyprint linenums">
scale(100);  //Returns 10
scale(300);  //Returns 180
scale(500);  //Returns 350</pre>
	<p>Как правило, вы будете вызывать эту функцию внутри метода <i>attr()</i> или ему подобных. Давайте, наконец, изменим нашу точечную диаграмму теперь уже с использованием динамического масштабирования.</p>
	<br/>
	<h3>Масштабируем точечную диаграмму</h3>
	<p>Давайте посмотрим на наш набор данных для точечной диаграммы:</p>
	<pre class="prettyprint linenums">
var dataset = [
                [5, 20], [480, 90], [250, 50], [100, 33], [330, 95],
                [410, 12], [475, 44], [25, 67], [85, 21], [220, 88]
              ];</pre>
	<p>Вспомните, что набор данных представляет из себя массив массивов. Мы использовали первое значение в каждом массиве как координату <i>х</i>, а второе значение, как координату <i>y</i>. Давайте начнем с оси <i>x</i>.</p>
	<p>Если долго пялиться на наш набор данных, можно сделать вывод, что значения <i>х</i> варьируются от 5 и до 480, поэтому вполне резонно сделать для них входную область значений 0-500, так?</p>
	<p>...</p>
	<p>Почему вы на меня так смотрите? Ааа, потому что вы хотите, чтобы ваш код был гибким и масштабируемым, чтобы он работал, даже если наши данные изменятся в будущем. Умно!</p>
	<p>Вместо того, чтобы указывать фиксированные значения для задания области входных значений, мы можем использовать подходящие для этих целей методы <i>min()</i> и <i>max()</i>, чтобы анализировать наш набор данных автоматически. Например, код ниже перебирает каждое значение <i>x</i> в наших подмассивах и возвращает наибольшее значение:</p>
	<pre class="prettyprint linenums">
d3.max(dataset, function(d) {    //Returns 480
    return d[0];  //References first value in each sub-array
});</pre>
	<p>Соберем наш код вместе и получим масштабирующую функцию для оси <i>x</i>:</p>
	<pre class="prettyprint linenums">
var xScale = d3.scale.linear()
                     .domain([0, d3.max(dataset, function(d) { return d[0]; })])
                     .range([0, w]);</pre>
	<p>Во-первых, заметьте, что я назвал эту функцию <i>xScale</i>. Конечно, вы можете назвать вашу масштабирующую функцию как вы захотите, но текущее название позволяет нам помнить, что делает наша функция.</p>
	<p>Во-вторых, заметьте, что для минимального значения области входных значений я выставил 0(Еще можно использовать метод <i>min()</i> аналогично тому, как мы использовали <i>max</i>). Максимальным значением области входных значений является максимальное значение в нашем наборе данных(которое равно 480).</p>
	<p>И в конечном итоге, я установил выходной диапазон значений <i>0-w</i>, то есть ширина нашего SVG.</p>
	<p>Мы будем использовать точно такой же подход  для создания масштабируемой функции для оси <i>y</i>:</p>
	<pre class="prettyprint linenums">
var yScale = d3.scale.linear()
                     .domain([0, d3.max(dataset, function(d) { return d[1]; })])
                     .range([0, h]);</pre>
	<p>Обратите внимание что метод <i>max()</i> ссылается на <i>d[1]</i>, координату y нашего подмассива. Также максимальным значением выходного диапазона(метод <i>range()</i>) выставлено <i>h</i> вместо <i>w</i>.</p>
	<p>Масштабирующие функции готовы! Теперь все что нам надо - это использовать их. Просто изменим код, где мы создавали круг для каждого элемента нашего набора данных:</p>
	<pre class="prettyprint linenums">
.attr("cx", function(d) {
    return d[0];
})</pre>
	<p>и изменим его, используя масштабирующую функцию:</p>
	<pre class="prettyprint linenums">
.attr("cx", function(d) {
    return xScale(d[0]);
})</pre>
	<p>Повторим этот подход и для оси <i>y</i>. Заменим старый код:</p>
	<pre class="prettyprint linenums">
.attr("cy", function(d) {
    return d[1];
})</pre>
	<p>на:</p>
	<pre class="prettyprint linenums">
.attr("cy", function(d) {
    return yScale(d[1]);
})</pre>
	<p>Теперь сделаем такие же изменения в тех местах, где мы устанавливаем координаты для текстовых меток. Так, старый код ниже:</p>
	<pre class="prettyprint linenums">
.attr("x", function(d) {
    return d[0];
})
.attr("y", function(d) {
    return d[1];
})</pre>
	<p>превращается в:</p>
	<pre class="prettyprint linenums">
.attr("x", function(d) {
    return xScale(d[0]);
})
.attr("y", function(d) {
    return yScale(d[1]);
})</pre>
	<p>Готово!</p>
	<img src="images/scales_1.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/150-scales/1.html">Смотрим на результат рабочего кодa</a>. На взгляд, результат разочаровывает, поскольку уж сильно похож на нашу оригинальную точечную диаграмму. Хотя мы достигли куда большего прогресса, чем мы видим.</p>
	<br/>
	<h3>Переработка диаграммы</h3>
	<p>Возможно, вы заметили, что меньшие значения y расположены в верхней части диаграммы, а большие значения y расположены ближе к низу. Теперь, так как мы используем масштабирующую функцию, супер просто поменять расположение больших и маленьких значений местами: чтобы большие значения были расположены в верхней части диаграммы, как можно было бы и ожидать. Мы просто изменим выходной диапазон для <i>yScale</i>, меняя:</p>
	<pre class="prettyprint linenums">.range([0, h]);</pre>
	<p>на:</p>
	<pre class="prettyprint linenums">.range([h, 0]);</pre>
	<img src="images/scales_2.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/150-scales/2.html">Здесь пример этого кода</a>. Да, теперь меньшим значениям y на входе соответствуют большие значения y на выходе, тем самым получается эффект, которого мы добивались. Я знаю, это так легко!</p>
	<p>Так как некоторые элементы изображения обрезаются, введем переменную отступа от краев:</p>
	<pre class="prettyprint linenums">var padding = 20;</pre>
	<p>Теперь мы включим эту переменную в расчет диапазона выходных значений как по оси <i>x</i>, так и по оси <i>y</i>. Раньше <i>xScale</i> был <i>range([0, w])</i>, теперь:</p>
	<pre class="prettyprint linenums">.range([padding, w - padding]);</pre>
	<p>Раньше <i>yScale</i> был <i>range([h, 0])</i>, теперь:</p>
	<pre class="prettyprint linenums">.range([h - padding, padding]);</pre>
	<p>Теперь у нас есть в запасе 20 пикселей сверху, снизу, слева, справа SVG-элемента, которые не берутся в расчет. И готово!</p>
	<img src="images/scales_3.png" alt="Результат работы кода">
	<p>Но текстовые метки справа до сих пор могут обрезаться. Тогда, я просто увеличу отступ справа в два раза:</p>
	<pre class="prettyprint linenums">.range([padding, w - padding * 2]);</pre>
	<img src="images/scales_4.png" alt="Результат работы кода">
	<p>Лучше. <a href="http://alignedleft.com/content/03-tutorials/01-d3/150-scales/3.html">Здесь пример рабочего кода.</a> Но есть еще одно изменение, которое я бы хотел сделать. Вместо того, чтобы рассчитывать радиус каждого круга как квадратный корень от значения <i>y</i>(что вообще бесполезное, в контексте текущей задачи, занятие), почему бы не создать еще одну функцию масштабирования?</p>
	<pre class="prettyprint linenums">
var rScale = d3.scale.linear()
                     .domain([0, d3.max(dataset, function(d) { return d[1]; })])
                     .range([2, 5]);</pre>
	<p>Потом устанавливаю радиус круга таким образом:</p>
	<pre class="prettyprint linenums">
.attr("r", function(d) {
    return rScale(d[1]);
});</pre>
	<p>Мы теперь гарантируем, что наши значения радиуса будут находиться в диапазоне значений 2-5(или почти всегда. Смотрите ссылку на метод <i>clamp()</i> ниже). Так, значения 0(минимальное число в области входных значений) будут иметь окружность радиусом 2 пикселя(или диаметр 4 пикселя), а очень большим значениям будут соответствовать круги с радиусом 5(диаметром 10) пикселей.</p>
	<img src="images/scales_5.png" alt="Результат работы кода">
	<p><a href="http://alignedleft.com/content/03-tutorials/01-d3/150-scales/4.html">Вуаля!</a> Наша первая масштабирующая функция, которая не участвует в расчете координат.</p>
	<p>И в конце, в случае, если сила нашей масштабирующей функции не взорвала ваше воображение, я бы хотел добавить еще один массив в наш начальный набор данных: [600, 150]</p>
	<img src="images/scales_6.png" alt="Результат работы кода">
	<p>Бум! <a href="http://alignedleft.com/content/03-tutorials/01-d3/150-scales/5.html">Здесь этот рабочий код.</a> Обратите внимание, как все старые значения сохраняют свои позиции, но сместились немного ближе друг к другу, вниз и влево, чтобы было место новому значению.</p>
	<p>А теперь, последнее откровение: сейчас мы можем очень просто изменить размер нашего SVG, и все будет смасштабировано самостоятельно. Здесь, я увеличил переменную <i>h</i> с 100 до 300, и больше никаких изменений не сделал:</p>
	<img src="images/scales_7.png" alt="Результат работы кода">
	<p>И снова, бум! <a href="http://alignedleft.com/content/03-tutorials/01-d3/150-scales/6.html">Рабочий пример обновленного кода.</a> Надеюсь, вы видите это и осознаете: больше не будет бессонных ночей, проведенных за модификацией кода только потому что клиент решил, что график должен быть в ширину 800 пикселей вместо задуманных 600. Да, вы будете спать благодаря мне(и блестящим встроенным методам D3)! Быть хорошо отдохнувшим - это конкурентное преимущество. Вы можете меня поблагодарить позже.</p>
	<br/>
	<h3>Другие методы</h3>
	<p><i>d3.scale.linear()</i> имеет несколько других удобных методов, которые заслуживают краткого упоминания здесь:</p>
	<ul>
		<li><a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#linear_nice"><i>nice()</i></a> - он говорит масштабирующей функции принять все что угодно в качестве выходного диапазона и расширить этот диапазон в обе стороны до ближайшего округленного значения. Выдержка из wiki D3: "Например, для области входных данных [0.20147987687960267, 0.996679553296417], метод вернет [0.2, 1]". Это удобно для людей, кому сложно читать цифры, подобные этой: 0.20147987687960267.</li>
		<li><a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#linear_rangeRound"><i>rangeRound()</i></a> - используйте этот метод вместе <i>range()</i>, и все выходные значения масштабирующей функции будут округлены до ближайшего целого числа. Этот метод полезен случае, когда вам нужны фигуры с точными значениями пикселей, чтобы избежать нечетких краев, которые могут возникнуть при сглаживании.</li>
		<li><a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#linear_clamp"><i>clamp()</i></a>  - по-умолчанию, линейное масштабирование может возвращать значения вне указанного выходного диапазона. Например, если дано значение, находящееся за пределами входной области значений, масштабирующая функция также вернет значение, расположенное вне диапазоны выходных значений. Если вызвать метод <i>.clamp(true)</i> в масштабирующей функции, заставляет все возвращаемые значения придерживаться выходного диапазона. Это означает, что такие выходные значения будут приравнены к минимальному или максимальному(что ближе) значению выходного диапазона.</li>
	</ul>
	<br/>
	<h3>Другие масштабирующие функции</h3>
	<p>В дополнение к <a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#linear">линейной масштабирующей функции</a>(которая описана выше), библиотека D3 обладает еще несколькими масштабирующими функциями:</p>
	<ul>
		<li><a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#identity"><i>identity</i></a> - масштаб в пропорции 1:1, в первую очередь полезно, для пиксельных величин.</li>
		<li><a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#sqrt"><i>sqrt</i></a> - функция масштабирования квадратного корня.</li>
		<li><a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#pow"><i>pow</i></a> - функция масштабирования возведения в степень.</li>
		<li><a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#log"><i>log</i></a> - логарифмическая функция масштабирования.</li>
		<li><a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#quantize"><i>quantize</i></a> - линейная функция масштабирования с дискретными значениями выходного диапазона.</li>
		<li><a href="https://github.com/mbostock/d3/wiki/Quantitative-Scales#quantile"><i>quantile</i></a> - аналогична функции выше, но дискретными значениями на входной области значений.</li>
		<li><a href="https://github.com/mbostock/d3/wiki/Ordinal-Scales"><i>ordinal</i></a> - порядковое масштабирование использует не количественные значения(как категории имен) на выходе; подходит для сравнения яблок с апельсинами.</li>
	</ul>
						
						<div class="row bg-cyan" id="bottom_navigation" style="padding: 20px 0; display: none;">
						</div>
					</div>
				</div>
				<!--div class="row">
					<div class="span12">
						<div id="disqus_thread"></div>
					</div>
				</div-->
				<div class="row">
					<div class="span12" style="padding-top: 30px; text-align:right;">
						<span class="text-muted">Автором оригинального текста книги <a href="http://alignedleft.com/tutorials/d3">D3 Tutorials</a> является <a href="http://alignedleft.com/">Scott Murray</a></span>
						<br/>
						<span class="text-muted">На русский язык перевел <a href="http://serganbus.github.io/">Ivanov Sergey</a>. 2014 год</span>
					</div>
				</div>
			</div>
		</div>
		
		<!--script type="text/javascript">
		var lPageName_str = location.href.match(/[^/]+\.html/i)[0];
		var lPageDescription_str = getPageProperty(lPageName_str, "description");
		
		/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = "serganbus"; // required: replace example with your forum shortname
		var disqus_identifier = "http://serganbus.github.io//d3tutorials/" + lPageName_str;
		var disqus_url = "http://serganbus.github.io//d3tutorials/" + lPageName_str;
		var disqus_category_id = "3309433";
		
        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
		</script-->
		
		<script>
			/*Google Analytics*/
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
			(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
			m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
			ga('create', 'UA-55961107-1', 'auto');
			ga('send', 'pageview');
		</script>
	</body>
</html>
