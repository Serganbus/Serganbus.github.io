<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: D3js | Блог программиста]]></title>
  <link href="http://Serganbus.github.io/blog/categories/d3js/atom.xml" rel="self"/>
  <link href="http://Serganbus.github.io/"/>
  <updated>2015-01-24T15:20:15+06:00</updated>
  <id>http://Serganbus.github.io/</id>
  <author>
    <name><![CDATA[Сергей Иванов]]></name>
    <email><![CDATA[sega234@mail.ru]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Масштабирующие функции в D3]]></title>
    <link href="http://Serganbus.github.io/blog/2015/01/20/scales-in-d3/"/>
    <updated>2015-01-20T23:28:30+06:00</updated>
    <id>http://Serganbus.github.io/blog/2015/01/20/scales-in-d3</id>
    <content type="html"><![CDATA[<p>Приветствую! <br/>
В этом цикле статей я попытаюсь доступно объяснить, что такое масштабирование применительно к визуализации данных, зачем оно нужно, и как оно представлено в библиотеке D3. Надеюсь, будет познавательно.</p>

<!-- more -->


<p>При разработке визуализации данных всегда имеется одна и та же ключевая задача, которую вам приходится решать снова и снова: сопоставление входным данным  визуальных образов. Например, необходимо сопоставить недавно купленный смартфон за 18000р с столбиком высотой 240 пикселей, а также ваш последний поход в кафе, который обошелся в 1453р со столбиком высотой, скажем 50 пикселей. В каком-то смысле, это все, что представляет из себя визуализация данных - сопоставление входным данным каких-либо характеристик визуальных образов так, чтобы при взгляде на визуализацию сразу было ясно о чем идет речь.</p>

<p>В первую очередь следует сказать, что в D3 функции масштабирования являются одновременно и объектами. Как объект, они имеют собственные методы, которые необходимы для настройки функций масштабирования. <br/>
Еще необходимо упомянуть, что в D3 использование функций масштабирования для построения визуализаций не является обязательным. Тем не менее, использование их  может невероятно упростить процесс преобразования входного набора данных в визуальные образы.</p>

<p>Но ближе к делу. <br/>
Как мы знаем из курса школьной математики, функция — это правило, по которому каждому элементу одного множества (называемого областью определения) ставится в соответствие некоторый элемент другого множества (называемого областью значений), то есть:
<img class="center" src="/images/posts/function.png" width="311" height="209" title="&lsquo;Функция&rsquo; &lsquo;Функция&rsquo;" >
Множество A - область определения; множество B - область значений. <br/>
Так вот: в документации к D3 масштабирующие функции разелены на три вида: <br/>
1. Функции, область определения которых представлена всякого рода числовыми последовательностями. Буду называть их количественными функциями масштабирования(в англ. документации quantitative); <br/>
2. Функции, область определения которых представлена разными множествами. Буду называть их порядковыми функциями масштабирования(в англ. документации ordinal); <br/>
3. Функции, область определения которых представлена датами, то есть временные функции масштабирования. <br/>
Так как описание каждого вида масштабирующей функции само по себе включает много текста, пояснений и изображений, я решил для каждого вида функции масштабирования выделить отдельную запись. По мере выкладывания новой записи, раскрывающей использование той или иной функции масштабирования, в этом посте будут обновляться ссылки.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Продвинутая столбиковая диаграмма с использованием D3.js]]></title>
    <link href="http://Serganbus.github.io/blog/2014/12/13/advanced-bar-chart/"/>
    <updated>2014-12-13T23:49:49+06:00</updated>
    <id>http://Serganbus.github.io/blog/2014/12/13/advanced-bar-chart</id>
    <content type="html"><![CDATA[<p>Приветствую!
Сегодня мы поговорим об обязательных атрибутах продвинутой столбиковой диграммы и о том, как ее реализовывать с использованием библиотеки визуализации данных D3.js. В моем переводе краткого руководства уже затрагивалась тема построения столбиковой диаграммы, однако продвинутой ее назвать язык просто не поворачивается. Кто еще не читал это краткое руководство, оно находится <a href="http://serganbus.github.io/d3tutorials/making_bar_chart.html">здесь</a>.</p>

<p>Допустим, нам необходимо показать, сколько денег мы тратим каждый день в течении месяца. Логично, что для этого дела мы выбрали столбиковую диаграмму. Для начала определимся, что же из себя представляет продвинутая столбиковая диаграмма? Минимальным набором для такой диаграммы является набор столбиков, оси и метки на осях. Хорошо если диаграмма будет иметь легенду(по-русски: подпись). Еще лучше, если диаграмма будет интерактивная. Представьте: наводишь мышью на столбик, а он подсвечивается, да еще и отображается посказка, какое значение отображает этот столбик! И верхом всего будет продвинутая интерактивность. Давайте же выполним задуманное.</p>

<!-- more -->


<p>Делаем все по порядку.</p>

<h4>Этап 1. Простая диаграмма</h4>

<p>Сначала реализуем диаграмму с минимальным набором. Тут расписывать нечего, так как пользуемся лишь знаниями, полученными при чтении <a href="http://serganbus.github.io/d3tutorials/index.html">переведенного руководства</a>.
Смотрим на <a href="http://jsfiddle.net/Serganbus/0gbjxqf2/">результат</a>. Сразу выявляется недочет: подписи на горизонтальной оси накладываются друг на другу, тем самым не давая себя прочитать. Если мы проанализируем в web-inspector&#8217;e, из чего состоит одна метка на оси, то увидим следующее:
<img class="center" src="/images/posts/advanced_bar_chart_1.jpg" width="602" height="172" title="&lsquo;Web Inspector&rsquo; &lsquo;Web Inspector&rsquo;" >
То есть, метка состоит из линии и подписи. И подпись у нас никак не корректируется в зависимости от ширины столбика. Выглядит ужасно и очень не информативно. Чтобы это исправить, нам нужно сделать так, чтобы подпись для каждого столбика корректировалась в зависимости от ширины этого столбика.  Концептуально можно выделить такую последовательность действия для решения этой задачи: <br/>
1. Выбираем все метки на горизонтальной оси методом <a href="https://github.com/mbostock/d3/wiki/Selections#d3_selectAll">d3.selectAll()</a>; <br/>
2. Поворачиваем подпись метки на такой угол, чтобы ее ширина была соизмерима с шириной столбика; <br/>
3. Позиционируем подпись метки так, чтобы было ясно, к какому столбику она относится; <br/>
Для реализации пункта 1 модифицируем код создания горизонтальной оси:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var lHorizontalAxis = chart.append(&ldquo;g&rdquo;)
</span><span class='line'>    .attr(&ldquo;class&rdquo;, &ldquo;x axis&rdquo;)
</span><span class='line'>    .attr(&ldquo;transform&rdquo;, &ldquo;translate(0, &rdquo; + chartHeight + &ldquo;)&rdquo;)
</span><span class='line'>    .call(xAxis)
</span><span class='line'>    .selectAll(&ldquo;g.tick&rdquo;)
</span><span class='line'>    .call(tickTextWrapping, xScale.rangeBand());</span></code></pre></td></tr></table></div></figure>
Теперь, как видите, я выбираю все контейнеры, хранящие метки, и для полученный выборки вызываю метод <em>tickTextWrapping</em>, в котором технически реализованы пункты 2 и 3. Код метода:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>function tickTextWrapping(aTick, aTextMaxWidth) {
</span><span class='line'>    var lTickTextsWidth = 0;
</span><span class='line'>    aTick.each(function (d) {
</span><span class='line'>        var lTick = d3.select(this);
</span><span class='line'>        lTick.select(&ldquo;text&rdquo;).remove();
</span><span class='line'>        var lTextContainerInitialX = 0;
</span><span class='line'>        var lTextContainerInitialY = 17;
</span><span class='line'>        var lTextContainer = lTick.append(&ldquo;g&rdquo;).attr(&ldquo;transform&rdquo;, &ldquo;translate(&rdquo; + lTextContainerInitialX + &ldquo;, &rdquo; + lTextContainerInitialY + &ldquo;)&rdquo;);
</span><span class='line'>        var lText = lTextContainer.append(&ldquo;text&rdquo;).text(d).style(&ldquo;text-anchor&rdquo;, &ldquo;middle&rdquo;);
</span><span class='line'>        var lTextWidth = lText[0][0].clientWidth;
</span><span class='line'>        var lTextHeight = lText[0][0].clientHeight;
</span><span class='line'>        if (aTextMaxWidth/lTextWidth &lt; 1) {
</span><span class='line'>            var lTextRadian = Math.acos(aTextMaxWidth/lTextWidth) * 180 / Math.PI;
</span><span class='line'>            var lTextIndent = lTextHeight / 2;
</span><span class='line'>            lTextContainerInitialY -= lTextIndent;
</span><span class='line'>            lText.attr(&ldquo;transform&rdquo;, &ldquo;rotate(&rdquo; + -lTextRadian + &ldquo;)&rdquo;).attr(&ldquo;dy&rdquo;, lTextIndent).style(&ldquo;text-anchor&rdquo;, &ldquo;middle&rdquo;);
</span><span class='line'>            var lTextContainerWidth = -lTextWidth * Math.sin(aTextMaxWidth/lTextWidth) / 2 + lTextContainerInitialX;
</span><span class='line'>            var lTextContainerHeight = lTextWidth * Math.cos(aTextMaxWidth/lTextWidth) / 2 + lTextContainerInitialY;
</span><span class='line'>            lTextContainer.attr(&ldquo;transform&rdquo;, &ldquo;translate(&rdquo; + lTextContainerWidth + &ldquo;, &rdquo; + lTextContainerHeight + &ldquo;)&rdquo;);
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>
Метод на вход принимает набор меток, а также максимально допустимую ширину метки. Кстати, внутри этого метода можно делать с метками все что душе угодно. Так что советую запомнить этот прием. <br/>
Итак, смотрим на полученный <a href="http://jsfiddle.net/Serganbus/0gbjxqf2/1/">результат</a>. <br/>
Теперь если мы добавим данные о тратах за все дни месяца, у нас все равно получится очень красивая и наглядная диаграмма. <a href="http://jsfiddle.net/Serganbus/0gbjxqf2/2/">Полученный результат</a>.</p>

<h4>Этап 2. Добавляем легенду</h4>

<p>Для большей информативности добавим легенду:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var lChartCaption = &ldquo;График расхода денежных средств за ноябрь 2014&rdquo;;
</span><span class='line'>chart.append(&ldquo;text&rdquo;)
</span><span class='line'>    .attr(&ldquo;x&rdquo;, chartWidth / 2)
</span><span class='line'>    .attr(&ldquo;y&rdquo;, -chartMargin.top / 2)
</span><span class='line'>    .style({&ldquo;text-anchor&rdquo;: &ldquo;middle&rdquo;, &ldquo;font&rdquo;: &ldquo;24px Courier New&rdquo;})
</span><span class='line'>    .text(lChartCaption);</span></code></pre></td></tr></table></div></figure>
<a href="http://jsfiddle.net/Serganbus/0gbjxqf2/3/">Результат с легендой</a>. <br/>
Еще приятнее и информативнее стала выглядеть наша диаграмма.</p>

<h4>Этап 3. Добавляем интерактивность</h4>

<p>Сделаем так, чтобы при наведении курсором на столбик он выделялся. Это делается простым добавлением CSS-стилей:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>svg rect.bar:hover {
</span><span class='line'>    fill: #00C12B;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>
<a href="http://jsfiddle.net/Serganbus/0gbjxqf2/4/">Результат</a>. <br/>
Для достижения большей интерактивности сделаем так, чтобы при наведении куросором столбик не только выделялся, но и отображалась сверху подсказка со значением столбика. <br/>
Для этого мы создаем на для каждого столбика отдельную подсказку, воспользовавшись элементом polygon:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var labelsContainers = chart.selectAll(&ldquo;g.label&rdquo;)
</span><span class='line'>    .data(dataset)
</span><span class='line'>    .enter()
</span><span class='line'>    .append(&ldquo;g&rdquo;)
</span><span class='line'>    .attr(&ldquo;class&rdquo;, &ldquo;label&rdquo;)
</span><span class='line'>    .attr(&ldquo;transform&rdquo;, function (d) {
</span><span class='line'>        var lInitialX = xScale(d.label);
</span><span class='line'>        var lX = lInitialX + xScale.rangeBand() / 2;
</span><span class='line'>        var lY = yScale(d.data);
</span><span class='line'>        return &ldquo;translate(&rdquo; + lX + &ldquo;, &rdquo; + lY + &ldquo;)&rdquo;;
</span><span class='line'>    })
</span><span class='line'>    .attr(&ldquo;id&rdquo;, function (d, i) { return &ldquo;label&rdquo; + i; })
</span><span class='line'>    .style(&ldquo;display&rdquo;, &ldquo;none&rdquo;);
</span><span class='line'>labelsContainers.append(&ldquo;polygon&rdquo;)
</span><span class='line'>    .attr(&ldquo;points&rdquo;, &ldquo;0,0 -5,-10 -50,-10 -50,-50 50,-50 50,-10 5,-10&rdquo;);
</span><span class='line'>labelsContainers.append(&ldquo;text&rdquo;)
</span><span class='line'>    .attr(&ldquo;id&rdquo;, function (d, i) { return &ldquo;date&rdquo; + i; })
</span><span class='line'>    .attr(&ldquo;x&rdquo;, &ldquo;0&rdquo;)
</span><span class='line'>    .attr(&ldquo;y&rdquo;, function (d) {
</span><span class='line'>        return -35;
</span><span class='line'>    })
</span><span class='line'>    .style(&ldquo;text-anchor&rdquo;, &ldquo;middle&rdquo;)
</span><span class='line'>    .text(function (d) { return &ldquo;Дата: &rdquo; + d.label; });
</span><span class='line'>labelsContainers.append(&ldquo;text&rdquo;)
</span><span class='line'>    .attr(&ldquo;id&rdquo;, function (d, i) { return &ldquo;value&rdquo; + i; })
</span><span class='line'>    .attr(&ldquo;x&rdquo;, &ldquo;0&rdquo;)
</span><span class='line'>    .attr(&ldquo;y&rdquo;, function (d) {
</span><span class='line'>        return -15;
</span><span class='line'>    })
</span><span class='line'>    .style(&ldquo;text-anchor&rdquo;, &ldquo;middle&rdquo;)
</span><span class='line'>    .text(function (d) { return &ldquo;Расходы: &rdquo; + d.data; });</span></code></pre></td></tr></table></div></figure>
И на каждый столбик вешаем обработчики &ldquo;mouseenter&rdquo; и &ldquo;mouseleave&rdquo;, которые управляют отображением подсказок:
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>.on(&ldquo;mouseenter&rdquo;, function (d, i) {
</span><span class='line'>        chart.select(&ldquo;#label&rdquo; + i).style(&ldquo;display&rdquo;, &ldquo;block&rdquo;);
</span><span class='line'>    })
</span><span class='line'>    .on(&ldquo;mouseleave&rdquo;, function (d, i) {
</span><span class='line'>        chart.select(&ldquo;#label&rdquo; + i).style(&ldquo;display&rdquo;, &ldquo;none&rdquo;);
</span><span class='line'>    });</span></code></pre></td></tr></table></div></figure>
Таким образом, наша продвинутая стобликовая диаграмма готова!
<a href="http://jsfiddle.net/Serganbus/0gbjxqf2/5/">Конечный результат</a>.</p>
]]></content>
  </entry>
  
</feed>
